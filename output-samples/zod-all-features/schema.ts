// Generated by dtolator --from-json-schema test-zod-all-features.json --zod
// Do not modify manually

import { z } from "zod";
export const RootSchema = z.object({
  /** Basic string field */
  basicString: z.string(),
  /** String with min/max length and regex pattern */
  stringWithConstraints: z.string().min(3).max(50).regex(/^[a-zA-Z]+$/),
  /** UUID format string */
  uuid: z.guid(),
  /** Email format string */
  email: z.email(),
  /** URI format string */
  uri: z.url(),
  /** ISO date string */
  date: z.iso.date(),
  /** ISO datetime string */
  dateTime: z.iso.datetime({ offset: true }),
  /** Basic floating-point number */
  basicNumber: z.number(),
  /** Number with min/max constraints */
  numberWithConstraints: z.number().min(0).max(100),
  /** Integer number */
  integer: z.number().int(),
  /** Integer with range constraints */
  integerWithRange: z.number().min(1).max(10).int(),
  /** Boolean field */
  booleanField: z.boolean(),
  /** Array of strings */
  stringArray: z.array(z.string()),
  /** Array of numbers */
  numberArray: z.array(z.number()),
  /** Array of objects */
  objectArray: z.array(z.object({
  id: z.number().int(),
  name: z.string().optional(),
})),
  /** Enum string */
  enumField: z.enum(["active", "inactive", "pending"]),
  /** Union of string or number */
  unionField: z.union([
  z.string(),
  z.number()
]),
  nestedObject: z.object({
  level1: z.object({
  level2: z.object({
  value: z.string(),
}),
}),
}),
  /** Nullable string */
  nullableString: z.string().nullable(),
  /** Optional field (not in required array) */
  optionalField: z.string().optional(),
  /** Complex nested array */
  complexArray: z.array(z.object({
  tags: z.array(z.string()).optional(),
  score: z.number().min(0).max(1).optional(),
})),
  /** Intersection of two object schemas using allOf */
  intersectionField: z.intersection(z.object({
  id: z.guid(),
}), z.object({
  email: z.email(),
})),
});

export type Root = z.infer<typeof RootSchema>;
