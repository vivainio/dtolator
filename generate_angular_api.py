import requests
import json
import traceback
import re
from pathlib import Path
import subprocess
import argparse
from dataclasses import dataclass

"""
python generate_angular_api.py --port PORT --gen-dir GEN_DIR
"""

@dataclass
class Args:
    port: int
    gen_dir: str
    angular_apis: str = None

def parse_args() -> Args:
    parser = argparse.ArgumentParser(description='Generate Angular API from OpenAPI specification')
    parser.add_argument('--port', type=int, required=True,
                        help='Port number for the OpenAPI endpoint')
    parser.add_argument('--gen-dir', type=str, required=True,
                        help='Directory to generate API files')
    parser.add_argument('--angular-apis', type=str,
                        help='Directory to generate Angular API services with UserApi naming convention')
    args = parser.parse_args()
    return Args(port=args.port, gen_dir=args.gen_dir)

ROOT_DIR = Path(__file__).parent.absolute()


def snake_to_camel(snake_case_string: str) -> str:
    words = snake_case_string.split("_")
    return words[0] + "".join(word.capitalize() for word in words[1:])


def to_snake_case(other_case: str) -> str:
    return re.sub(r"(?<!^)(?=[A-Z])", "-", other_case).lower()


def get_type(py_type: dict, schema: dict):
    if "anyOf" in py_type:
        types = []
        for i in py_type["anyOf"]:
            if "const" in i:
                types.append(i["const"])
            else:
                types.append(get_type(i, None))
        unique_types = list(set(types))
        # Sort with null and undefined always last
        def sort_types(type_name):
            if type_name in ["null", "undefined"]:
                return (1, type_name)  # Put null/undefined last
            return (0, type_name)  # Everything else first, alphabetically
        unique_types.sort(key=sort_types)
        return " | ".join(unique_types)
    if "$ref" in py_type:
        return re.findall(r"([A-Za-z0-9]*\[?\]?$)", py_type["$ref"])[0]
    if "items" in py_type:
        return "Array<" + get_type(py_type["items"], schema) + ">"
    if "enum" in py_type:
        return py_type["title"]
    if "type" not in py_type:
        return "any"
    if py_type["type"] == "array":
        return "Array<" + get_type(schema["items"], schema) + ">"
    if py_type["type"] == "integer":
        return "number"
    if py_type["type"] == "dict":
        return "{[key: string]: any}"
    if py_type["type"] == "object" and "additionalProperties" in py_type:
        #if isinstance(py_type["additionalProperties"], bool):
        #    py_type["additionalProperties"] = {"type": "boolean"}
        value = get_type(py_type["type"], schema)
        return "{[key: string]: " + value + "}"
    return py_type["type"]


def write_subs_to_url(gen_dir: Path):
    content = """
    // This file is automatically generated. Don't edit.
    // Run at repository root uv run after_api_changes.py to re-generate this file.

    import { environment } from "@env/environment";

    export function subsToUrl(
        url: string,
        params?: { [key: string]: string | number | boolean | null | undefined},
        queryParams?: { [key: string]: string | number | boolean | null | undefined }
    ): string {
        if (params) {
            for (const key in params) {
                if (params.hasOwnProperty(key)) {
                    const regex = new RegExp(":" + key + "($|/)");
                    url = url.replace(regex, params[key] + "$1");
                }
            }
        }
        if (queryParams) {
            const qs = Object.keys(queryParams)
            .filter((key) => queryParams[key] !== null && queryParams[key] !== undefined)
            .map((key) => {
                const value = encodeURIComponent(queryParams[key]!);
                return `${key}=${value}`;
            })
            .join("&");
            if (qs.length > 0) {
            url += "?" + qs;
            }
        }

        const injectedConfig = (window as any).API_CONFIG;
        if (injectedConfig) {
            return injectedConfig.BACKEND_API_URL + url;
        }

        return environment.apiUrl + url;
    }
"""

    with Path.open(gen_dir / "subs-to-url.func.ts", "w") as f:
        f.write(content)


def generate_dtos(response: dict, gen_dir: Path):
    dto_list = ["// This file is automatically generated. Don't edit.",
                "// Run at repository root uv run after_api_changes.py to re-generate this file.",
                ""]
    seen_schemas = set()
    for schema in response["components"]["schemas"]:
        if schema in seen_schemas:
            raise ValueError(f"Duplicate schema found: {schema}. Please resolve the naming conflict in your DTOs.")
        seen_schemas.add(schema)
        
        if not schema.endswith("DTO") and not schema.endswith("Enum"):
            print("Skipping", schema, "doesn't end with DTO or Enum")
            continue
        print("Creating DTO for", schema)
        dto = []
        if schema in ["HTTPValidationError", "ValidationError"]:
            continue
        if "properties" in response["components"]["schemas"][schema]:
            dto.append("export interface " + schema + "{")
            properties = []
            for property in response["components"]["schemas"][schema]["properties"]:
                type = response["components"]["schemas"][schema]["properties"][property]
                # print("Extracting property", property, "with type",type)
                properties.append(f"{property}: {get_type(type, type)}")
            dto.extend(properties)
            dto.append("}")
            dto.append("")
        elif "enum" in response["components"]["schemas"][schema]:
            # print("Enum found")
            enum_values: list[str] = response["components"]["schemas"][schema]["enum"]
            enum_name = response["components"]["schemas"][schema]["title"]
            dto.append("export enum " + enum_name + " {")
            enum_values_list = []
            for key in enum_values:
                target = key
                key = key.replace("'", "")
                key = key.replace(" ", "_").upper()
                enum_values_list.append(key + '= "' + target + '",')
            dto.extend(enum_values_list)
            dto.append("}")
            dto.append("")
        # needed for enums with only 1 option
        elif (
            "const" in response["components"]["schemas"][schema]
            and "title" in response["components"]["schemas"][schema]
            and "Enum" in response["components"]["schemas"][schema]["title"]
        ):
            enum_values: list[str] = [
                response["components"]["schemas"][schema]["const"]
            ]
            enum_name = response["components"]["schemas"][schema]["title"]
            dto.append("export enum " + enum_name + " {")
            for value in enum_values:
                dto.append(value + '= "' + value + '",')
            dto.append("}")
            dto.append("")
        dto_list.append("\n".join(dto))
    dto_list.sort()
    with Path.open(gen_dir / "dto.ts", "w") as f:
        f.write("\n".join(dto_list))


def generate_interfaces(response: dict, gen_dir: Path, skip_paths: set):
    api_services: dict[str, list[str]] = {}
    for path in response["paths"]:
        #print(skip_paths)
        if any(skip_path in path for skip_path in skip_paths if path.startswith(skip_path)):
            print("---- Skipping", path)
            continue
        for method in response["paths"][path].keys():
            print("Generating interface for", method, path)
            try:
                name = response["paths"][path][method]["summary"].replace(" ", "")
                if "tags" not in response["paths"][path][method]:
                    continue
                service_name = response["paths"][path][method]["tags"][0] + "ApiService"
                if service_name not in api_services:
                    api_services[service_name] = {
                        "imports": [],
                        "methods": [],
                    }
                name = name[0].lower() + name[1:]

                parameters = []
                parameter_map = {}
                if "parameters" in response["paths"][path][method]:
                    for param in response["paths"][path][method]["parameters"]:
                        parameter_map[param["name"]] = snake_to_camel(param["name"])
                        parameter_type = get_type(param["schema"], {})
                        for splitted_param_type in parameter_type.split(" | "):
                            if splitted_param_type not in set(["string", "number", "boolean", "null", "undefined"]):
                                api_services[service_name]["imports"].append(splitted_param_type)
                        parameters.append(
                            f"{parameter_map[param['name']]}: {parameter_type}"
                        )
                # We are interested in response types 200 or 201
                response_type = response["paths"][path][method]["responses"]["200"][
                    "content"
                ]["application/json"]["schema"]["$ref"].replace("#/components/schemas/", "")
                api_services[service_name]["imports"].append(response_type)

                request_payload = ""
                if "requestBody" in response["paths"][path][method]:
                    dto_type = response["paths"][path][method]["requestBody"]["content"][
                        "application/json"
                    ]["schema"]["$ref"].replace("#/components/schemas/", "")
                    parameters.append("dto: " + dto_type)
                    api_services[service_name]["imports"].append(dto_type)
                    request_payload = ", dto"
                elif method == "post":
                    request_payload = ", {}"

                api_method = (
                    name
                    + "("
                    + ",".join(parameters)
                    + f"): Observable<{response_type}>"
                    + "{"
                )

                p = re.sub("<[a-z]*:", ":", path).replace("}", "").replace("{", ":")
                if "parameters" in response["paths"][path][method]:
                    parameters = response["paths"][path][method]["parameters"]
                    path_parameters = [param["name"] for param in parameters if param["in"] == "path"]
                    query_paramters = [param["name"] for param in parameters if param["in"] == "query"]
                    api_method += f'const url = subsToUrl("{p}", {{{",".join(path_parameters)}}}, {{{",".join(query_paramters)}}});'
                else:
                    api_method += f'const url = subsToUrl("{p}", {{}}, {{}});'
                for k, v in parameter_map.items():
                    api_method = api_method.replace(k, v)

                api_method += (
                    f"return this.http.{method}<{response_type}>(url{request_payload});"
                    + "}\n"
                )
                api_services[service_name]["methods"].append(api_method)
            except Exception:
                print("Error generating interface for", method, path)
                print("Perhaps typing is missing")
                print(traceback.format_exc())

    index = ['export * from "./dto";', 'export * from "./subs-to-url.func";']

    for k, v in api_services.items():
        class_name = k[0].upper() + k[1:].replace("_","")
        content = [
            "",
            '@Injectable({ providedIn: "root" })',
            f"export class {class_name} " + "{",
            "",
            "constructor(private http: HttpClient){}\n",
        ]
        v["methods"].sort()
        content.extend(v["methods"])
        content.append("}")
        imports = list(set(v["imports"]))
        imports.sort()
        imports = [
            'import { HttpClient } from "@angular/common/http";',
            'import { Injectable } from "@angular/core";',
            'import { Observable } from "rxjs";',
            'import { subsToUrl } from "./subs-to-url.func";',
        ] + ["import {" + ",".join(imports) + '} from "./dto";']
        content.insert(0, "\n".join(imports))
        content.insert(0, "")
        content.insert(0, "// Run at repository root uv run after_api_changes.py to re-generate this file.\n")
        content.insert(0, "// This file is automatically generated. Don't edit.\n")

        file_name = to_snake_case(k).replace("api-service", "api.service").replace("_","-")

        index.append(f'export * from "./{file_name}";')

        with Path.open(gen_dir / f"{file_name}.ts", "w") as f:
            f.write("\n".join(content))

    index.sort()
    with Path.open(gen_dir / "index.ts", "w") as f:
        f.write("\n".join(index))


def prettify(gen_dir: Path):
    subprocess.check_call("npx prettier *.ts --write", shell=True, cwd=str(gen_dir))


def generate_all(gen_dir: Path, open_api_url: str,
                 skip_paths: set) -> None:
    # Remove all api__dtos__xxx_dto__ patterns from the response
    response_content = requests.get(open_api_url).content.decode("utf-8")
    response_content = re.sub(r'api__dtos__[a-zA-Z_]+_dto__', '', response_content)
    response = json.loads(response_content)

    with Path.open(ROOT_DIR / "openapi.json", "w") as f:
        json.dump(response, f, indent=2)
    generate_dtos(response, gen_dir)
    generate_interfaces(response, gen_dir, skip_paths)
    write_subs_to_url(gen_dir)
    prettify(gen_dir)

if __name__ == "__main__":
    try:
        args = parse_args()
        gen_dir = Path(args.gen_dir)
        open_api_url = f"http://localhost:{args.port}/api/openapi.json"
        gen_dir.mkdir(parents=True, exist_ok=True)
        generate_all(gen_dir, open_api_url, set(["/health-check"]))


    except Exception:
        print("Error creating angular api. Maybe services are not running?")
        print(traceback.format_exc())