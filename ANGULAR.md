# Angular API Generation Documentation

## Overview

This document outlines the practices and conventions for automatically generating TypeScript interfaces, DTOs, and Angular services from OpenAPI specifications.

## Using the dtolator Tool

### Command Line Usage

The dtolator tool now supports Angular API generation with the `--angular` flag:

```bash
# Generate Angular API services in a directory
dtolator --input openapi.json --output ./src/app/api --angular

# Generate Angular API services with Zod validation
dtolator --input openapi.json --output ./src/app/api --angular --zod

# Generate with Promises instead of Observables
dtolator --input openapi.json --output ./src/app/api --angular --promises

# Generate to stdout (single combined output)  
dtolator --input openapi.json --angular
```

### Generated Files Structure

When using `--angular` with an output directory, the following files are generated:

```
api-output/
├── dto.ts                    # TypeScript interfaces
├── users-api.ts             # Service for Users tag
├── products-api.ts          # Service for Products tag (if exists)
└── index.ts                 # Barrel exports
```

When using `--angular --zod` with an output directory, additional validation is included:

```
api-output/
├── dto.ts                    # TypeScript type re-exports from schema.ts
├── schema.ts                 # Zod validation schemas with runtime validation
├── users-api.ts             # Service with built-in Zod validation
├── products-api.ts          # Service with built-in Zod validation
└── index.ts                 # Barrel exports
```

## Generated Angular Services

### Service Example (Without Zod)

Given this OpenAPI specification:

```json
{
  "paths": {
    "/users": {
      "get": {
        "tags": ["Users"],
        "summary": "List All Users",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "type": "array", "items": { "$ref": "#/components/schemas/User" } }
              }
            }
          }
        }
      },
      "post": {
        "tags": ["Users"], 
        "summary": "Create New User",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": { "$ref": "#/components/schemas/CreateUserRequest" }
            }
          }
        },
        "responses": {
          "201": {
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/ApiResponse" }
              }
            }
          }
        }
      }
    },
    "/users/{userId}": {
      "get": {
        "tags": ["Users"],
        "summary": "Get User By ID", 
        "parameters": [
          {
            "name": "userId",
            "in": "path",
            "required": true,
            "schema": { "type": "integer" }
          }
        ],
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/User" }
              }
            }
          }
        }
      }
    }
  }
}
```

The tool generates this Angular service:

```typescript
// users-api.ts
// Generated by dtolator
// Do not modify manually

import type { HttpClient, HttpHeaders } from "@angular/common/http";
import { Injectable, inject } from "@angular/core";
import type { Observable } from "rxjs";

import type { ApiResponse, CreateUserRequest, User } from "./dto";

@Injectable({ providedIn: 'root' })
export class UsersApi {
  private http = inject(HttpClient);
  private baseUrl: string;

  constructor() {
    this.baseUrl = (globalThis as any).API_URL || (typeof window !== 'undefined' && (window as any).API_URL);
    if (!this.baseUrl) throw new Error('API_URL is not configured');
  }

  /**
   * List All Users
   *
   * Retrieve a list of all users in the system
   *
   * @param headers - Optional HTTP headers
   * @returns Observable<User[]> - Successful response
   */
  listAllUsers(headers?: HttpHeaders): Observable<User[]> {
    const url = `${this.baseUrl}/users`;
    return this.http.get<User[]>(url, { headers });
  }

  /**
   * Create New User
   *
   * Create a new user account
   *
   * @param dto - Request body of type CreateUserRequest
   * @param headers - Optional HTTP headers
   * @returns Observable<ApiResponse> - User created successfully
   */
  createNewUser(dto: CreateUserRequest, headers?: HttpHeaders): Observable<ApiResponse> {
    const url = `${this.baseUrl}/users`;
    return this.http.post<ApiResponse>(url, dto, { headers });
  }

  /**
   * Get User By ID
   *
   * Retrieve a specific user by their ID
   *
   * @param userId - Path parameter of type number
   * @param headers - Optional HTTP headers
   * @returns Observable<User> - User found
   */
  getUserByID(userId: number, headers?: HttpHeaders): Observable<User> {
    const url = `${this.baseUrl}/users/${encodeURIComponent(userId)}`;
    return this.http.get<User>(url, { headers });
  }
}
```

### With Zod Validation

When using the `--zod` flag, the generated service includes runtime validation:

```typescript
// users-api.ts
// Generated by dtolator
// Do not modify manually

import type { HttpClient, HttpHeaders } from "@angular/common/http";
import { Injectable, inject } from "@angular/core";
import type { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { z } from "zod";

import { ApiResponseSchema, UserSchema } from "./dto";
import type { ApiResponse, CreateUserRequest, User } from "./dto";

@Injectable({ providedIn: 'root' })
export class UsersApi {
  private http = inject(HttpClient);
  private baseUrl: string;

  constructor() {
    this.baseUrl = (globalThis as any).API_URL || (typeof window !== 'undefined' && (window as any).API_URL);
    if (!this.baseUrl) throw new Error('API_URL is not configured');
  }

  /**
   * List All Users
   *
   * Retrieve a list of all users in the system
   *
   * @param headers - Optional HTTP headers
   * @returns Observable<User[]> - Successful response
   */
  listAllUsers(headers?: HttpHeaders): Observable<User[]> {
    const url = `${this.baseUrl}/users`;
    return this.http.get<User[]>(url, { headers })
      .pipe(
        map(response => z.array(UserSchema).parse(response))
      );
  }

  /**
   * Create New User
   *
   * Create a new user account
   *
   * @param dto - Request body of type CreateUserRequest
   * @param headers - Optional HTTP headers
   * @returns Observable<ApiResponse> - User created successfully
   */
  createNewUser(dto: CreateUserRequest, headers?: HttpHeaders): Observable<ApiResponse> {
    const url = `${this.baseUrl}/users`;
    return this.http.post<ApiResponse>(url, dto, { headers })
      .pipe(
        map(response => ApiResponseSchema.parse(response))
      );
  }

  /**
   * Get User By ID
   *
   * Retrieve a specific user by their ID
   *
   * @param userId - Path parameter of type number
   * @param headers - Optional HTTP headers
   * @returns Observable<User> - User found
   */
  getUserByID(userId: number, headers?: HttpHeaders): Observable<User> {
    const url = `${this.baseUrl}/users/${encodeURIComponent(userId)}`;
    return this.http.get<User>(url, { headers })
      .pipe(
        map(response => UserSchema.parse(response))
      );
  }
}
```

### With Promises (--promises flag)

When using the `--promises` flag, methods return Promises instead of Observables:

```typescript
// users-api.ts
import { lastValueFrom } from "rxjs";

// ... other imports

listAllUsers(headers?: HttpHeaders): Promise<User[]> {
  const url = `${this.baseUrl}/users`;
  return lastValueFrom(this.http.get<User[]>(url, { headers }));
}
```

### URL Building

The generated services use TypeScript template strings for building URLs:

- **Base URL**: Services use a `baseUrl` property configured via `API_URL` global variable
- **Path Parameters**: Automatically encoded using `encodeURIComponent()` in template strings
- **Query Parameters**: Passed as `params` option to HttpClient methods

```typescript
// Example URL building in generated service
getUserByID(userId: number, headers?: HttpHeaders): Observable<User> {
  const url = `${this.baseUrl}/users/${encodeURIComponent(userId)}`;
  return this.http.get<User>(url, { headers });
}

// With query parameters
searchUsers(queryParams: SearchUsersQueryParams, headers?: HttpHeaders): Observable<User[]> {
  const url = `${this.baseUrl}/users`;
  return this.http.get<User[]>(url, { headers, params: queryParams });
}
```

### TypeScript DTOs

The generated `dto.ts` contains strongly-typed interfaces:

```typescript
// dto.ts
// Generated by dtolator
// Do not modify manually

export interface User {
  id: number;
  email: string;
  name: string;
  age?: number;
  isActive?: boolean;
  tags?: string[];
  status?: "active" | "inactive" | "pending";
}

export interface CreateUserRequest {
  email: string;
  name: string;
  age?: number | null;
}

export interface ApiResponse {
  success: boolean;
  message?: string;
  data?: User;
}
```

### Index File

The `index.ts` provides convenient barrel exports:

```typescript
// index.ts  
// Generated by dtolator
// Do not modify manually

export * from "./dto";
export * from "./users-api";
```

## Service Usage in Angular Components

### Component Example

```typescript
import { Component, OnInit } from '@angular/core';
import { UsersApi, User, CreateUserRequest } from '../api';

@Component({
  selector: 'app-user-list',
  template: `
    <div *ngFor="let user of users">
      <h3>{{ user.name }}</h3>
      <p>{{ user.email }}</p>
      <button (click)="loadUser(user.id)">View Details</button>
    </div>
    
    <button (click)="createUser()">Create New User</button>
  `
})
export class UserListComponent implements OnInit {
  users: User[] = [];

  constructor(private usersApi: UsersApi) {}

  ngOnInit() {
    this.loadUsers();
  }

  loadUsers() {
    this.usersApi.listAllUsers().subscribe({
      next: (users) => this.users = users,
      error: (err) => console.error('Failed to load users:', err)
    });
  }

  loadUser(userId: number) {
    this.usersApi.getUserByID(userId).subscribe({
      next: (user) => console.log('User details:', user),
      error: (err) => console.error('Failed to load user:', err)
    });
  }

  createUser() {
    const newUser: CreateUserRequest = {
      email: 'john@example.com',
      name: 'John Doe',
      age: 30
    };

    this.usersApi.createNewUser(newUser).subscribe({
      next: (response) => {
        console.log('User created:', response);
        this.loadUsers(); // Refresh the list
      },
      error: (err) => console.error('Failed to create user:', err)
    });
  }
}
```

### Global API URL Configuration

Set the API URL globally before bootstrapping your Angular application:

```typescript
// main.ts
import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';

// Configure API URL
(globalThis as any).API_URL = 'https://api.example.com/v1';

bootstrapApplication(AppComponent, {
  // ... your app config
});
```

## Current Functionality

### Generated Files Structure
```
gen-dir/
├── dto.ts                    # TypeScript interfaces and enums
├── users-api.ts             # Service for Users tag
├── products-api.ts          # Service for Products tag
└── index.ts                 # Barrel exports
```

## Service Generation Logic

### 1. Service Grouping
Services are grouped by the **first tag** in the OpenAPI specification:
- Each endpoint's `tags[0]` determines which service it belongs to
- Endpoints without tags are **skipped**
- All endpoints with the same tag go into the same service class

### 2. Service Naming Convention
- **Service Name**: `{Tag}Api` (e.g., `UsersApi`)
- **File Name**: `{tag}-api.ts` (e.g., `users-api.ts`)
- **Class Name**: `{Tag}Api` with proper PascalCase

### 3. Method Naming Convention
Method names are derived from the OpenAPI `summary` field:
1. Take the `summary` value
2. Remove all spaces: `"Get User By ID"` → `"GetUserByID"`
3. Convert to camelCase: `"GetUserByID"` → `"getUserByID"`

## OpenAPI Requirements

### Essential Fields for Proper Generation

#### 1. Tags (Required)
```json
{
  "paths": {
    "/users": {
      "get": {
        "tags": ["Users"],  // First tag determines service grouping
        "summary": "Get All Users"
      }
    }
  }
}
```

#### 2. Summary Fields (Required)
```json
{
  "summary": "Get User Profile By ID"  // Becomes method name: getUserProfileByID()
}
```

#### 3. Response Schemas (Required)
```json
{
  "responses": {
    "200": {
      "content": {
        "application/json": {
          "schema": {
            "$ref": "#/components/schemas/UserDTO"  // Must reference a DTO
          }
        }
      }
    }
  }
}
```

#### 4. Schema Naming Convention
- **DTOs**: Must end with `DTO` (e.g., `UserDTO`, `CreateUserRequestDTO`)
- **Enums**: Must end with `Enum` (e.g., `UserStatusEnum`)
- Other schemas are skipped

## Best Practices for OpenAPI Specifications

### 1. Meaningful Summary Fields
❌ **Bad**: Generic summaries
```json
"summary": "Get users"
"summary": "Create user" 
"summary": "List products"
```

✅ **Good**: Descriptive summaries
```json
"summary": "Get All Users With Pagination"
"summary": "Create New User Account"
"summary": "Search Products With Filters"
```

### 2. Consistent Tagging
❌ **Bad**: Inconsistent or missing tags
```json
// No tags - endpoint will be skipped
"get": { "summary": "Get Users" }

// Inconsistent casing
"tags": ["users", "Users", "user"]
```

✅ **Good**: Consistent tag naming
```json
"tags": ["Users"]     // All user-related endpoints
"tags": ["Products"]  // All product-related endpoints
"tags": ["Orders"]    // All order-related endpoints
```

### 3. Proper DTO Structure
```json
{
  "components": {
    "schemas": {
      "UserDTO": {
        "type": "object",
        "required": ["id", "email"],
        "properties": {
          "id": { "type": "string" },
          "email": { "type": "string", "format": "email" }
        }
      }
    }
  }
}
```

## Generated Service Example

Given this OpenAPI specification:
```json
{
  "paths": {
    "/users": {
      "get": {
        "tags": ["Users"],
        "summary": "Get All Users With Pagination",
        "responses": {
          "200": {
            "content": {
              "application/json": {
                "schema": { "$ref": "#/components/schemas/UserListDTO" }
              }
            }
          }
        }
      }
    }
  }
}
```

Generates this Angular service:
```typescript
// users-api.ts
import type { HttpClient, HttpHeaders } from "@angular/common/http";
import { Injectable, inject } from "@angular/core";
import type { Observable } from "rxjs";

import type { UserListDTO } from "./dto";

@Injectable({ providedIn: 'root' })
export class UsersApi {
  private http = inject(HttpClient);
  private baseUrl: string;

  constructor() {
    this.baseUrl = (globalThis as any).API_URL || (typeof window !== 'undefined' && (window as any).API_URL);
    if (!this.baseUrl) throw new Error('API_URL is not configured');
  }

  getAllUsersWithPagination(headers?: HttpHeaders): Observable<UserListDTO> {
    const url = `${this.baseUrl}/users`;
    return this.http.get<UserListDTO>(url, { headers });
  }
}
```

## Alternative Naming Convention

### Simplified Structure
```
angular-apis/
├── user-api.ts         # UserApi class
├── product-api.ts      # ProductApi class  
├── order-api.ts        # OrderApi class
└── index.ts            # Barrel exports
```

### Simplified Naming Convention
- **File Names**: `{tag}-api.ts` (e.g., `user-api.ts`, `product-api.ts`)
- **Class Names**: `{Tag}Api` (e.g., `UserApi`, `ProductApi`)
- **Method Names**: Same camelCase convention from summary

### Example Generated Service (Alternative)
```typescript
// user-api.ts
import { Injectable, inject } from '@angular/core';
import type { HttpClient, HttpHeaders } from '@angular/common/http';
import type { Observable } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class UserApi {
  private http = inject(HttpClient);
  private baseUrl: string;

  constructor() {
    this.baseUrl = (globalThis as any).API_URL || (typeof window !== 'undefined' && (window as any).API_URL);
    if (!this.baseUrl) throw new Error('API_URL is not configured');
  }

  getAllUsersWithPagination(headers?: HttpHeaders): Observable<UserListDTO> {
    const url = `${this.baseUrl}/users`;
    return this.http.get<UserListDTO>(url, { headers });
  }

  createNewUserAccount(dto: CreateUserRequestDTO, headers?: HttpHeaders): Observable<UserDTO> {
    const url = `${this.baseUrl}/users`;
    return this.http.post<UserDTO>(url, dto, { headers });
  }
}
```

## Current Limitations

1. **Tag Dependency**: Endpoints without tags are completely skipped
2. **First Tag Only**: Only the first tag is used for grouping
3. **DTO Naming**: Only schemas ending with "DTO" or "Enum" are processed
4. **Response Assumption**: Assumes 200 responses always exist
5. **Fixed File Structure**: No flexibility in generated file organization

## Recommendations

1. **Always include tags** in your OpenAPI specification
2. **Use descriptive summaries** that translate to good method names
3. **Follow DTO naming conventions** with proper suffixes
4. **Group related endpoints** under the same tag
5. **Test generated code** with sample OpenAPI specs before production use

## Error Handling

The generation process will:
- **Skip endpoints** without tags (with console warning)
- **Continue processing** if individual endpoints fail
- **Report errors** for missing response schemas
- **Validate DTO naming** and skip non-conforming schemas